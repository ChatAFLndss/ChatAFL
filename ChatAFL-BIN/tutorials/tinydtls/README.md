Below are the steps necessary to fuzz [TinyDTLS], a DTLS 1.2 server implementation for IoT devices.
A similar approach can be used to fuzz other DTLS server implementations.

# Step-0. Build Contiki-ng TinyDTLS
  
    export WORKDIR=$(pwd)
    cd $WORKDIR
    
    # fork de-randomized version of TinyDTLS commit 094143f (the latest commit as of now)
    git clone git@github.com:assist-project/tinydtls-fuzz.git tinydtls
    
    # building de-randomized version 
    (cd tinydtls/tests; git checkout 06995d4; CC=afl-clang-fast make clean all)
    
# Step-1. Test TinyDTLS installation
In two separate terminals run the client and the server and check that they can communicate (over port 20220).

Run server:

    ./tinydtls/tests/dtls-server
    
Run client:
    
    ./tinydtls/tests/dtls-client localhost

# Step-2. Fuzzing
For fuzzing DTLS implementations we use server/client messages generated by our de-randomized dtls-client/dtls-server utilities. 
De-randomization ensures that each concrete sequence of inputs prompts a unique response of the system.
We use the '-W' option to tweak the response polling timout after sending each input. 

TinyDTLS supports two cipher suites, one (Eliptic Curve) EC-based, the other (Pre-shared Keys) PSK-based. 
EC handling is slow, requiring use of a large polling timeout which slows down fuzzing considerably.
One may consider disabling it in the server application 'dtls-server.c'.
This can be done by undefining 'DTLS_ECC' in 'dtls-server.c' .
That way, the polling timeout can be reduced, speeding up fuzzing.

Fuzzing:

    afl-fuzz -d -i $AFLNET/tutorials/tinydtls/handshake_captures/ -o out-tinydtls/ -N udp://127.0.0.1/20220 -P DTLS12 -D 10000 -q 3 -s 3 -E -K -R -W 30 ./tinydtls/tests/dtls-server

(D)TLS responses do not have status codes. 
To overcome this, we encode a status code as a touple <content_type, message_type>, where content_type and message_type correspond to, respectively, the content type carried in the record header, and message type in the message payload (which depends on the content type).
They are extracted from the responses.
We use custom types for cases where the types cannot be determined due to (suspected) encryption or when the message appears malformed.

A status code is computed as follows:

    status_code = (content_type << 8) + message_type;

The status_code is presented in decimal format in the ipsm which blurs its structure.
This can be amended by using its hex representation, in which the first 2 letters correspond to content_type and the next two to the message_type.
These represenation can be obtained by running:

    printf '%x' status_code

If the status_code is 5635 this will yield 1603, which can be interpreted:

  - 16 - Handshake Content Type
  - 03 - Hello Verify Request Message Type

For more detail on mapping DTLS 1.2 fields to types view the [TLS 1.2] and [DTLS 1.2] standards.


[TinyDTLS]:https://github.com/contiki-ng/tinydtls
[TLS 1.2]:https://tools.ietf.org/html/rfc5246
[DTLS 1.2]:https://tools.ietf.org/html/rfc6347
